--------------------------------------------------------------------------------------------------------------------------------------------------
a. Утверждение: "Используйте делегацию вместо наследования" 

    Делегация предполагает, что объект делегирует выполнение задачи другому объекту вместо того, чтобы наследовать его. Это позволяет избегать жесткой связи между классами, характерной для наследования, и обеспечивает гибкость.

    Пример делегации: 

    class Printer:
        def print_document(self, document):
            print(f"Printing: {document}")

    class Office:
        def __init__(self):
            self.printer = Printer()  # Делегируем задачи принтеру

        def print_document(self, document):
            self.printer.print_document(document)  # Делегируем вызов

    office = Office()
    office.print_document("Report.pdf")
    

    Здесь `Office` делегирует задачу печати классу `Printer`.
--------------------------------------------------------------------------------------------------------------------------------------------------

b. Ассоциация в ООП и ее разновидности 

    Ассоциация — это отношение между двумя классами, где один класс использует или связан с другим. Она бывает следующих видов:

    1.  Агрегация   
    Отношение "часть-целое", где части могут существовать отдельно от целого.  
        Пример: 
        python
    class Engine:
        pass

    class Car:
        def __init__(self, engine):
            self.engine = engine
        

    2.  Композиция   
    Частный случай агрегации, где часть не может существовать отдельно от целого.  
        Пример: 
        python
    class Heart:
        pass

    class Human:
        def __init__(self):
            self.heart = Heart()
        

    3.  Обычная ассоциация   
    Один объект использует другой без явного владения.  
        Пример: 
        python
    class Driver:
        def drive(self, car):
            print(f"Driving {car}")
        
--------------------------------------------------------------------------------------------------------------------------------------------------

c. Паттерн стратегия как пример делегации 

    Проблема:   
    Когда объект должен выполнять разные алгоритмы, лучше использовать делегацию вместо жесткого кодирования логики. Это позволяет динамически менять поведение.

    Применение:   
    Вместо того чтобы захламлять класс несколькими методами или сложными условиями, стратегии реализуют разные варианты поведения, и объект делегирует им выполнение задачи.

    Пример:
    class PaymentStrategy:
        def pay(self, amount):
            raise NotImplementedError

    class CreditCardPayment(PaymentStrategy):
        def pay(self, amount):
            print(f"Paying {amount} using Credit Card.")

    class PayPalPayment(PaymentStrategy):
        def pay(self, amount):
            print(f"Paying {amount} using PayPal.")

    class PaymentProcessor:
        def __init__(self, strategy: PaymentStrategy):
            self.strategy = strategy

        def process_payment(self, amount):
            self.strategy.pay(amount)

    processor = PaymentProcessor(PayPalPayment())
    processor.process_payment(100)
 
--------------------------------------------------------------------------------------------------------------------------------------------------

d. Пример наследования и паттерна стратегия 

    Наследование: 

    class Animal:
        def speak(self):
            raise NotImplementedError

    class Dog(Animal):
        def speak(self):
            return "Woof!"

    class Cat(Animal):
        def speak(self):
            return "Meow!"
    

    Стратегия: 

    class SpeakStrategy:
        def speak(self):
            raise NotImplementedError

    class DogSpeak(SpeakStrategy):
        def speak(self):
            return "Woof!"

    class CatSpeak(SpeakStrategy):
        def speak(self):
            return "Meow!"

    class Animal:
        def __init__(self, speak_strategy: SpeakStrategy):
            self.speak_strategy = speak_strategy

        def speak(self):
            return self.speak_strategy.speak()

    dog = Animal(DogSpeak())
    print(dog.speak())  # Woof!
    

    Разница:   
    Стратегия позволяет динамически менять поведение (`DogSpeak` на `CatSpeak`), тогда как наследование фиксирует поведение в классе.

--------------------------------------------------------------------------------------------------------------------------------------------------

e. Пример, когда паттерн не нужен 

    Если поведение объекта не меняется и достаточно фиксированной функциональности, то нет необходимости в паттерне.  
        Пример:  Калькулятор с базовыми операциями (`add`, `subtract`).

--------------------------------------------------------------------------------------------------------------------------------------------------

f. Класс для работы с БД 

    Класс, отвечающий за работу с базой данных, часто называется `Database` или `Repository`. Работа осуществляется через:
    1. Установление соединения (например, через `sqlite3`, `SQLAlchemy`).
    2. Выполнение SQL-запросов.
    3. Обработку результатов (например, возвращение объектов или словарей).

--------------------------------------------------------------------------------------------------------------------------------------------------

g. Формат возвращаемого результата 

    Результат SQL-запроса `SELECT` обычно возвращается как:
    - Список кортежей (по умолчанию, например, в `sqlite3`).
    - Словари (при использовании ORM или настроек курсора).
    - Модели данных (если используется ORM, как `Django ORM` или `SQLAlchemy`).

--------------------------------------------------------------------------------------------------------------------------------------------------

h. Паттерн одиночка: проблема и применение 

    Проблема: Нужно гарантировать, что класс имеет только один экземпляр, например, для управления доступом к ресурсам (логирование, соединение с БД).

    Применение: Когда требуется централизованный контроль, например, единственная точка подключения к базе данных.

--------------------------------------------------------------------------------------------------------------------------------------------------

i. Пример реализации паттерна одиночка 

    class Singleton:
        _instance = None

        def __new__(cls, *args,  kwargs):
            if not cls._instance:
                cls._instance = super().__new__(cls)
            return cls._instance

    Проверка:
    singleton1 = Singleton()
    singleton2 = Singleton()
    print(singleton1 is singleton2)  # True
 
--------------------------------------------------------------------------------------------------------------------------------------------------

j. Зачем нужны поля и методы класса?

    Необходимость:
    1. Поля хранят состояние объекта (например, данные).
    2. Методы определяют поведение и логику работы с состоянием.

    Примеры: 
    1. Метод валидации данных перед сохранением в БД.
    2. Метод расчета, например, вычисление зарплаты на основе полей `hours` и `rate`.

    class Employee:
        def __init__(self, name, rate):
            self.name = name
            self.rate = rate

        def calculate_salary(self, hours):
            return self.rate * hours

--------------------------------------------------------------------------------------------------------------------------------------------------